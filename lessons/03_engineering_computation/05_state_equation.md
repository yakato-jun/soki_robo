# モデルと状態方程式の考え方

**前提知識**: 線形代数（02/02）、微積（02/03）

**目的**: 「モデル」の概念を理解する。状態方程式が行列とdtの話であることを知る。

---

## 「モデル」とは

現実を数式で近似したもの。それがモデルです。

### 例: 等速運動モデル

「ロボットは一定速度で動いている」と仮定する。

```
x[k+1] = x[k] + v × dt
```

- 現実: 加速したり減速したりする
- モデル: 速度は一定と仮定する

**完璧ではない。** でも、短い時間なら「だいたい合っている」。

### モデルが完璧でない理由

- 現実は非線形（複雑な動き）
- 外乱（風、路面の凹凸）
- パラメータの誤差（車輪径が設計値と違う）

> **モデルが完璧じゃないから、確率が必要になる。**
> モデルの誤差を「不確かさ」として扱い、観測で補正する。
> これがカルマンフィルタの考え方。

---

## 状態方程式

### 状態とは

ロボットの「今の状態」を数字の束（ベクトル）で表したもの。

```python
# 差動二輪ロボットの状態
x = np.array([
    px,    # x位置 [m]
    py,    # y位置 [m]
    theta, # 向き [rad]
])
```

「このベクトルが分かれば、ロボットの状態が完全に表せる」= 状態ベクトル。

### 状態方程式の形

```
x[k+1] = A × x[k] + B × u[k]
```

- **x[k]** : 今の状態（位置、速度、姿勢...）
- **u[k]** : 入力（モータへの命令）
- **A** : 状態遷移行列（「今の状態が次にどう変わるか」のルール）
- **B** : 入力行列（「入力が状態にどう効くか」のルール）
- **x[k+1]** : 次の状態

### これも行列とdtの話

線形代数で学んだ「出力 = 変換 × 入力」そのものです。

- 行列A: 物理法則を表す行列（大枠2の線形代数）
- dt: 更新の時間刻み（大枠2の微積）
- 行列とdtが合流する場所

---

## 具体例: 1Dの等速運動

最もシンプルなモデル:

```
状態: [位置, 速度]
入力: [加速度]

x[k+1] = A × x[k] + B × u[k]
```

```python
import numpy as np

dt = 0.1  # サンプリング周期

# 状態遷移行列
A = np.array([[1, dt],    # 位置 = 位置 + 速度 × dt
              [0,  1]])   # 速度 = 速度（等速）

# 入力行列
B = np.array([[0.5 * dt**2],  # 位置への寄与
              [dt]])           # 速度への寄与

# 初期状態
x = np.array([0.0, 1.0])  # 位置0m, 速度1m/s

# 入力なし（等速運動）
u = np.array([0.0])

# 10ステップ更新
for k in range(10):
    x = A @ x + B @ u
    print(f"t={k*dt:.1f}s: pos={x[0]:.2f}m, vel={x[1]:.2f}m/s")
```

出力:
```
t=0.0s: pos=0.10m, vel=1.00m/s
t=0.1s: pos=0.20m, vel=1.00m/s
...
t=0.9s: pos=1.00m, vel=1.00m/s
```

位置が0.1mずつ増える。速度1m/sで0.1秒ごとに更新しているから当然です。

---

## Aの意味を読み解く

```
A = (1  dt)
    (0   1)
```

- 1行目 `[1, dt]`: 次の位置 = 今の位置 × 1 + 今の速度 × dt
- 2行目 `[0, 1]` : 次の速度 = 今の位置 × 0 + 今の速度 × 1

Aの中身は物理法則を行列にしたものです。
「行列を読む = 物理法則を読む」。線形代数で学んだ構造の読み方がここで効きます。

---

## なぜ状態方程式が重要か

### 予測ができる

状態方程式があれば、「今の状態」から「未来の状態」を予測できます。

```python
# 5ステップ先を予測
x_future = x.copy()
for _ in range(5):
    x_future = A @ x_future + B @ u
```

### カルマンフィルタの土台

カルマンフィルタは:

1. **予測**: 状態方程式で「次はこうなるはず」を予測
2. **観測**: センサで「実際はこうだった」を得る
3. **更新**: 予測と観測を信頼度で混ぜて、推定を改善する

状態方程式は予測ステップの中核です。

### モデルの限界

状態方程式は「完璧なモデル」を前提にしています。
現実はモデル通りにはいかないので、予測には必ず誤差が出ます。

この誤差を「プロセスノイズ」と呼び、確率的に扱います。
「モデルが不完全 → 確率が必要」— 確率のレッスンで学んだことが、ここで繋がります。

---

## ここで覚えること

- モデル = 現実の数式近似。完璧ではない
- 状態方程式 `x[k+1] = A x[k] + B u[k]` は行列とdtの話
- Aの中身は物理法則、Bは入力の効き方
- 状態方程式があれば未来が予測できる
- モデルが完璧でないから確率が必要 → カルマンフィルタへ

---

**次のレッスン**: → #29 カルマンフィルタ (`03_engineering_computation/06_kalman_filter`)
